#include <iostream>

#define DEFAULT_BLOCK_COUNT 128
#define DEFAULT_TPB_COUNT   128

using namespace std;

typedef struct {
    int x;
    int y;
} GridSize;

typedef struct {
    int x;
    int y;
    int z;
} BlockSize;

GridSize  gs = {1, 1};
BlockSize bs = {1, 1, 1};

int   blockCnt  = DEFAULT_BLOCK_COUNT;
int   tpbCnt    = DEFAULT_TPB_COUNT;
int   totalThreads;

int * id; 

//Declaration of pointers to CPU memory (host)
int * blockx_h, * blocky_h;
int * idx_h,    * idy_h,    * idz_h;

//Declaration of pointers to GPU memory (device)
int * blockx_d, * blocky_d;
int * idx_d,    * idy_d,    * idz_d;

__global__ void MyFirstKernel(
    int * blkx, int * blky,
    int * idx, int * idy,  int * idz) {

    int blockId = (blockIdx.y * gridDim.x) + blockIdx.x;
    int f_threadId = (blockId * blockDim.z * blockDim.y * blockDim.x);

    int l_threadId = (threadIdx.z * blockDim.y * blockDim.x) +
                     (threadIdx.y * blockDim.x) +
                     threadIdx.x;

    int threadId = f_threadId + l_threadId;
    
    blkx[threadId] = blockIdx.x;
    blky[threadId] = blockIdx.y;
    idx[threadId]  = threadIdx.x;
    idy[threadId]  = threadIdx.y;
    idz[threadId]  = threadIdx.z;
}

int ParseArguments(int argc, char ** argv) {

    if (argc == 1) {
        cout << "Usage: " << argv[0] << " [gs.y] [gs.x] [bs.z] [bs.y] [bs.x]" << endl;
        return -1;
    }

    if (argc != 6) {
        cout << "Error: Not enough arguments specified." << endl;
        return -1;
    }
    
    for (int i=1;i<6;i++) {
        if (atoi(argv[i]) <= 0) {
            cout << "Error: Invalid arguments" << endl;
            return -1;
        }
    }

    gs.y = atoi(argv[1]);
    gs.x = atoi(argv[2]);
    bs.z = atoi(argv[3]);
    bs.y = atoi(argv[4]);
    bs.x = atoi(argv[5]);

    if (bs.x * bs.y * bs.z > 1024) {
        cout << "Error: Too many threads per block (<= 1024)" << endl;
        return -1;
    }

    return 0;
}

void CheckCudaError(cudaError_t ce) {

    if (ce == cudaSuccess)
        return;

    cout << "Error: " << cudaGetErrorString(ce) << endl;
    exit(-1);
}

int AllocateHostMemory(int totalThreads) {

    try { 
        blockx_h = new int[totalThreads];
        blocky_h = new int[totalThreads];

        idx_h = new int[totalThreads];
        idy_h = new int[totalThreads];
        idz_h = new int[totalThreads];
    }
    catch(bad_alloc e) {
        return -1;
    }

    return 0;
}

int main(int argc, char ** argv) {

    if (ParseArguments(argc, argv))
        exit(-1);

    totalThreads = gs.x * gs.y * bs.x * bs.y * bs.z;
    int totalMem = totalThreads * sizeof(int);

    if (AllocateHostMemory(totalThreads)) {
        cout << "Error: Memory allocation on host failed." << endl;
        exit(-1);
    }

    //Allocate memory on GPU to store block identifiers
    CheckCudaError(    cudaMalloc(&blockx_d, totalMem));
    CheckCudaError(    cudaMalloc(&blocky_d, totalMem));

    //Allocate memory on GPU to store thread identifiers
    CheckCudaError(    cudaMalloc(&idx_d, totalMem));
    CheckCudaError(    cudaMalloc(&idy_d, totalMem));
    CheckCudaError(    cudaMalloc(&idz_d, totalMem));

    //Clear allocated memory block on GPU for storing block identifiers to 0
    CheckCudaError(    cudaMemset(blockx_d, 0, totalMem));
    CheckCudaError(    cudaMemset(blocky_d, 0, totalMem));

    //Clear allocated memory block on GPU for storing thread identifiers to 0
    CheckCudaError(    cudaMemset(idx_d, 0, totalMem));
    CheckCudaError(    cudaMemset(idy_d, 0, totalMem));
    CheckCudaError(    cudaMemset(idz_d, 0, totalMem));

    //Invoke the kernel
    dim3 gridDim(gs.x, gs.y);
    dim3 blockDim(bs.x, bs.y, bs.z);
    MyFirstKernel <<<gridDim, blockDim>>>(
        blockx_d, blocky_d, idx_d, idy_d, idz_d);
    cudaDeviceSynchronize();

    //Copying data generated by the kernel from GPU back to CPU
    CheckCudaError(
        cudaMemcpy(blockx_h, blockx_d, totalMem, cudaMemcpyDeviceToHost));
    CheckCudaError(
        cudaMemcpy(blocky_h, blocky_d, totalMem, cudaMemcpyDeviceToHost));
    CheckCudaError(    
        cudaMemcpy(idx_h, idx_d, totalMem, cudaMemcpyDeviceToHost));
    CheckCudaError(
        cudaMemcpy(idy_h, idy_d, totalMem, cudaMemcpyDeviceToHost));
    CheckCudaError(
        cudaMemcpy(idz_h, idz_d, totalMem, cudaMemcpyDeviceToHost));

    for (int i=0;i<totalThreads;i++)
        cout << "[" << i << "]\t" << 
            blocky_h[i] << "\t" <<
            blockx_h[i] << "\t" <<
            idz_h[i] << "\t" <<
            idy_h[i] << "\t" <<
            idx_h[i] << endl;

    return 0;
}

